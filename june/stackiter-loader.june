// Imports.

var log = console.log;
var readFile = require('fs').readFile;


// Exports.
// TODO Auto-export.

exports.load = load;


// Functions.


// TODO Move clone out to some utility area.
// Cloning technique based on examples and discussions here:
// http://stackoverflow.com/questions/122102/
//   what-is-the-most-efficient-way-to-clone-a-javascript-object
// TODO Generics: function clone[Obj](obj: Obj): Obj { ... }
// TODO or maybe: function clone(obj: #Obj): #Obj { ... }
// TODO or something.
function clone(obj: Object?): Object? {
  // This could be more sophisticated about more types, but eh.
  if (obj == null || typeof(obj) != 'object') {
    return obj;
  }
  var copied = new obj.constructor;
  for (var key in obj) {
    var val = obj[key];
    copied[key] = clone(val);
  }
  return copied;
}


// TODO Options schema.
function load(file: String, options: Options): void {
  readFile(file, 'utf8', do(err, content) {
    if (err) throw err;
    log("Parsing " + file + " ...");
    var states = new Loader().parseAll(content.split(/\n/), options.stateLimit);
    if (options.ready) {
      options.ready(states);
    }
  });
}


// TODO Class support!!
function Loader() {

  // TODO Specify default types?
  // TODO var* args: String*;

  var indexes: Number* = [];
  var state: State = {cleared: false, items: [], time: 0};
  var states: State* = [];

  this.parseAll = parseAll;

  function findIndex(args: String*, argIndex: Number?): Number {
    // TODO Param default values! (Could it help avoid nulls?)
    if (argIndex == null) argIndex = 1;
    var id = Number(args[argIndex]);
    var index = indexes[id];
    if (index == null) throw "no such item";
    return index;
  }

  function findItem(args: String*, argIndex: Number?): Item {
    if (argIndex == null) argIndex = 1;
    return state.items[findIndex(args, argIndex)];
  }

  function parseAlive(args: String*): void {
    var item = findItem(args);
    item.alive = args[2] === 'true';
  }

  function parseAll(lines: String*, stateLimit: Number?): State* {
    // TODO Param default values! (Could it help avoid nulls?)
    if (stateLimit == null) stateLimit = Infinity;
    for (var l = 0; l < lines.length; l++) {
      var line = lines[l];
      parseLine(line);
      if (states.length >= stateLimit) {
        break;
      }
    }
    if (states.length < stateLimit) {
      states.push(clone(state));
    }
    return states;
  }

  function parseClear(args: String*): void {
    state.cleared = true;
  }

  function parseDestroy(args: String*): void {
    var index = findIndex(args);
    // Remove the item and update the indexes.
    state.items.splice(index, 1);
    for (var i = index; i < state.items.length; i++) {
      indexes[state.items[i].id]--;
    }
  }

  function parseExtent(args: String*): void {
    var item = findItem(args);
    item.extent[0] = Number(args[2]);
    item.extent[1] = Number(args[3]);
  }

  function parseGrasp(args: String*): void {
    var tool = findItem(args);
    var item = findItem(args, 2);
    tool.grasping = true;
    item.grasped = true;
  }

  function parseItem(args: String*): void {
    var id = Number(args[1]);
    indexes[id] = state.items.length;
    state.items.push({
      alive: false,
      color: [0, 0, 0],
      extent: [0, 0],
      grasped: false,
      grasping: false,
      id: id, // TODO Just 'id,'.
      location: [0, 0],
      orientation: 0,
      type: null,
      velocity: [0, 0]
    });
  }

  function parseLine(line: String): void {
    var args = line.trim().split(/\s+/);
    switch (args[0]) {
      case 'alive':
        parseAlive(args);
        break;
      case 'clear':
        parseClear(args);
        break;
      case 'destroy':
        parseDestroy(args);
        break;
      case 'extent':
        parseExtent(args);
        break;
      case 'grasp':
        parseGrasp(args);
        break;
      case 'item':
        parseItem(args);
        break;
      case 'pos':
        parsePos(args);
        break;
      case 'posvel':
        parsePosVel(args);
        break;
      case 'release':
        parseRelease(args);
        break;
      case 'rot':
        parseRot(args);
        break;
      case 'time':
        parseTime(args);
        break;
      case 'type':
        parseType(args);
        break;
    }
  }

  function parsePos(args: String*): void {
    item = findItem(args);
    item.location[0] = Number(args[2]);
    item.location[1] = Number(args[3]);
  }

  function parsePosVel(args: String*): void {
    // TODO Unify these that are similar form?
    item = findItem(args);
    item.velocity[0] = Number(args[2]);
    item.velocity[1] = Number(args[3]);
  }

  function parseRelease(args: String*): void {
    tool = findItem(args);
    item = findItem(args, 2);
    tool.grasping = false;
    item.grasped = false;
  }

  function parseRot(args: String*): void {
    var item = findItem(args);
    // TODO Angle is rats. Convert to radians or not?
    item.orientation = Number(args[2]);
  }

  function parseTime(args: String*): void {
    if (args[1] == 'sim') {
      states.push(clone(state));
      state.cleared = false;
      state.time = Number(args[3]);
    }
  }

  function parseType(args: String*): void {
    var item = findItem(args);
    item.type = args[2];
  }

}
