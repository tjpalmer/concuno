// Imports.

var log = console.log;
var max = Math.max, min = Math.min;


// Exports.

exports.learn = learn;


// Functions.


// Mapping function helpers.

function difference(mapper: Mapper): Mapper {
  var name = mapper.name;
  var map = mapper.map;
  if (map.length != 1) throw "#{name} arity #{map.length} != 1";
  return {
    name: "difference#{name[0].toUpperCase()}#{name[1..]}",
    map: (a, b) -> vectorDiff(map(a), map(b)),
  };
}


// Mapping functions.
var mappers: Mapper* = [];
(function() {
  // TODO Map syntax, such as {Mapper} or something?
  var mappersObj: Mappers = {};
  function putMapper(mapper: Mapper): void {
    mappersObj[mapper.name] = mapper;
  }
  // TODO Option semi on last statement.
  // TODO Do expressions??
  putMapper({name: 'location', map: do(entity) {return entity.location;}});
  putMapper(difference(mappersObj.location));
  // TODO Move mappers to a separate file, and just make the list here.
  for (var m in mappers) {
    mappers.push(mappers[m]);
  }
  // Sort mappers by arity. We prefer simpler models.
  mappers.sort(do(a, b) {return a.map.length - b.map.length;});
})();


function expandLeaf(leaf: LeafNode): void {
  log("Expanding leaf " + leaf.id + " ...");
  var minArity = mappers[0].map.length;
  var maxArity = mappers[mappers.length - 1].map.length;
  // Compare that to the number of vars available in this branch.
  var varDepth = leaf.varDepth();
  var minNewVarCount = max(0, minArity - varDepth);
  log("Min new var count: " + minNewVarCount);
  // Clone the tree, and start adding vars.
  // We prefer simpler trees, so the fewer nodes the better.
  var clone = leaf.root().clone();
  var node = clone.getNode(leaf.id);
  for (
    var addedVarCount = minNewVarCount;
    addedVarCount <= maxArity;
    addedVarCount++
  ) {
    log "Adding up to var #{addedVarCount}"
    var $var = clone.newVar();
    node.replaceWith($var);
    node = $var.kid;
    $var.parent.propagate();
    if (false) {
      // Poor man's benchmark.
      for (var i = 0; i < 1000; i++) {
        clone.propagate();
      }
      var bindingCount = 0;
      var bindings = clone.leaves[0].bindings;
      for (var b = 0; b < bindings.length; b++) {
        bindingCount += bindings[b].entityLists.length;
      }
      log("Bindings at leaf after 1000 props: " + bindingCount);
    }
    log("New var " + $var.id);
    log("New leaf " + node.id);
    varDepth++;
    for (var m = 0; m < mappers.length; m++) {
      var mapper = mappers[m];
      // End our loop once we don't have enough vars.
      if (mapper.map.length > varDepth) break;
      // And skip mappers for which we've added superfluous vars.
      if (mapper.map.length < addedVarCount) continue;
      split(node, mapper);
    }
  }
}


function getValueBags(bindingBags, mapper, indexes) {
  // TODO Provide the error bindings and bags immediately here, too?
  // TODO Or reloop later to pull those out?
  var bags: ValueBag* = [];
  for (var b = 0; b < bindingBags.length; b++) {
    var binding = bindingBags[b];
    var values: Object* = [];
    var entityLists = binding.entityLists;
    for (var e = 0; e < entityLists.length; e++) {
      var entitiesAll = entityLists[e];
      var entities: Entity* = [];
      for (var i = 0; i < indexes.length; i++) {
        entities.push(entitiesAll[indexes[i]]);
      }
      if (entities.indexOf(null) < 0) continue; // error case
      // TODO mapper.map.apply(, entities);
      values.push(mapper.map.apply(undefined, entities));
    }
    if (!values.length) continue; // no actual values
    bags.push({bag: binding.bag, values});
  }
}


split = (leaf, mapper) ->
  log "Splitting node #{leaf.id} on #{mapper.name} ..."
  // TODO Figure out which vars to use.
  // TODO Could figure out how many vars immediately above the current leaf.
  // TODO We should commit all those, but we could mix and match earliers.
  // TODO   committed = 0
  // TODO   node = leaf.parent
  // TODO   while node? and node.isVar()
  // TODO     committed++
  // TODO     node = node.parent
  // For now, just use the most recent vars.
  arity = mapper.map.length
  varDepth = leaf.varDepth()
  splitWithIndexes leaf, mapper, [varDepth-arity ... varDepth]


function learn(tree: Node): void {
  log("Learning ...");
  // TODO Better leaf picking.
  var leaves = tree.leaves();
  var leaf = leaves[0];
  expandLeaf(leaf);
}


splitWithIndexes = (leaf, mapper, indexes) ->
  log "Using indexes #{indexes} ..."
  initBagLimit = 4
  posCount = 0
  valueBags = getValueBags leaf.bindings, mapper, indexes
  for valueBag in valueBags
    if valueBag.bag.label
      //log valueBag
      break if ++posCount > initBagLimit
      for value in valueBag.values
        // TODO Calculate kernel or whatnot against all other bags.
        value
  // TODO Manual loops probably faster than list building here.
  if true
    valueCount = 0
    valueCount += valueBag.values.length for valueBag in valueBags
    log "Built #{valueCount} values in #{valueBags.length} bags"
    mins = vectorMin (vectorMin valueBag.values for valueBag in valueBags)
    maxes = vectorMax (vectorMax valueBag.values for valueBag in valueBags)
    log "Limits: #{mins} #{maxes}"
    //log values.join ' '


vectorDiff = (x, y) -> x[i] - y[i] for i in [0 ... x.length]


vectorMax = (vectors) ->
  if vectors.length and dim = vectors[0].length
    // This manual looping is substantially faster (3x?) than building a array
    // on the spot for each dim then using Math.max.
    // Slower version:
    // max (vectors[v][d] for v in [0...vectors.length])... for d in [0...dim]
    for d in [0...dim]
      maxVal = -Infinity
      for vector in vectors
        val = vector[d]
        if val > maxVal
          maxVal = val
      maxVal
  else
    []


vectorMin = (vectors) ->
  if vectors.length and dim = vectors[0].length
    // This manual looping is substantially faster (3x?) than building a array
    // on the spot for each dim then using Math.min.
    // Slower version:
    // min (vectors[v][d] for v in [0...vectors.length])... for d in [0...dim]
    for d in [0...dim]
      minVal = Infinity
      for vector in vectors
        val = vector[d]
        if val < minVal
          minVal = val
      minVal
  else
    []
