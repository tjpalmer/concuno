// Imports.

var dump = console.log;


// Exports.

exports.emptyBindings = emptyBindings;
exports.startTree = startTree;


// Functions.


class BindingBag {

  // TODO @bag on param like CoffeeScript/Scala???
  function BindingBag(bag: Sample) {
    // TODO @bag = bag;
    this.bag = bag;
    // TODO Need class defs to type these members!
    this.entityLists = [];
  };

  var bag: Sample;

  var entityLists: Array*; // TODO Entity** maybe?

};


class Node {

  function Node() {
    this.bindings = [];
    this.id = 0;
    this.parent = null;
    initKids(this);
  };

  var bindings: BindingBag*;

  var id: Number;

  var parent: Node?;

  function clone(): Node {
    // Mostly, we're okay keeping things just as prototypes. A bit risky if we
    // don't track the consequences (such as for bindings lists), but we make
    // a lot of clones, and avoiding copying data seems wise and simple.
    var Clone = function() {};
    Clone.prototype = this;
    var node = new Clone;
    var kids = this.kids();
    if (kids.length) {
      // We do want to copy the kids.
      // TODO Array comprehensions???
      var clonedKids: Node* = [];
      for (var k = 0; k < kids.length; k++) {
        clonedKids.push(kids[k]);
      };
      node.setKids(clonedKids);
    };
    return node;
  };

  function getNode(id: Number): Node? {
    if (this.id == id) {
      return this;
    } else {
      var kids = this.kids();
      // TODO for (kids) do(kid) {...};
      for (var k = 0; k < kids.length; k++) {
        var node = kids[k].getNode(id);
        if (node) {
          return node;
        };
      };
      return null;
    };
  };

  function isVar(): Boolean {
    return false;
  }

  function leaves(): Node* {
    var result: Node* = [];
    pushLeaves(this);
    return result;
    function pushLeaves(node) {
      var kids = node.kids();
      if (kids.length) {
        for (var k = 0; k < kids.length; k++) {
          pushLeaves(kids[k]);
        };
      } else {
        // This is a leaf.
        result.push(node);
      };
    };
  };

  function newLeaf(kid): LeafNode {
    return new LeafNode(kid);
  };

  function newSplit(kid): SplitNode {
    return new SplitNode(kid);
  };

  function newVar(kid): VarNode {
    return new VarNode(kid);
  };

  function replaceWith(node): void {
    if (this.parent) {
      var kids = this.parent.kids();
      for (var k = 0; k < kids.length; k++) {
        var kid = kids[k];
        if (kid.id == this.id) {
          this.parent.setKid(Number(k), node);
        };
      };
    };
  };

  function varDepth(): Number {
    var depth = 0;
    var node = this;
    while (node) {
      depth += node.isVar();
      node = node.parent;
    };
    return depth;
  };

  function root(): Node {
    return this.parent ? this.parent.root() : this;
  };

};


class LeafNode: Node {

  function LeafNode() {
    Node.call(this);
    this.prob = 0;
  };

  var prob: Number;

  function kids(): Node* {
    return [];
  };

  function propagate(bindings: BindingBag*): void {
    if (bindings) {
      // We got new bindings.
      this.bindings = bindings;
    };
  };

};


class RootNode: Node {

  function RootNode(kid: Node) {
    this.kid = kid || new LeafNode;
    // Set nextId before calling super, so kids will init correctly.
    this.nextId = 1;
    Node.call(this);
    this.bags = [];
  };

  var bags: Bag*;

  var kid: Node;

  var nextId: Number;

  function kids(): Node* {
    return [this.kid];
  };

  function generateId(): Number {
    return this.nextId++;
  };

  function propagate(bindings: BindingBag*): void {
    if (bindings) {
      // We got new bindings.
      this.bindings = bindings;
    } else {
      // We need to use the ones we already had.
      bindings = this.bindings;
    };
    // dump("RootNode to prop " + bindings.length + " bindings");
    this.kid.propagate(bindings);
  };

  function setKid(k: Number, kid: Node): void {
    if (k) throw "bad kid index " + k;
    this.kid = kid;
    initKids(this);
  };

  function setKids(kids: Node*): void {
    this.kid = kids[0];
    initKids(this);
  };

};


class SplitNode: Node {

  function SplitNode($true: Node, $false: Node, error: Node): void {
    this.$true = $true || new LeafNode;
    this.$false = $false || new LeafNode;
    this.error = error || new LeafNode;
    Node.call(this);
  };

  var $true: Node;
  var $false: Node;
  var error: Node;

  function kids(): Node* {
    return [this.$true, this.false, this.error];
  };

  function setKid(k: Number, kid: Node): void {
    var keys = ['$true', '$false', 'error'];
    this[keys[k]] = kid;
    initKids(this);
  };

  function setKids(kids) {
    this.$true = kids[0];
    this.$false = kids[1];
    this.error = kids[2];
    initKids(this);
  };

};


class VarNode: Node {

  function VarNode(kid: Node): void {
    this.kid = kid || new LeafNode;
    Node.call(this);
  };

  function isVar(): Boolean {
    return true;
  };

  function kids(): Node* {
    return [this.kid];
  };

  function propagate(bindings: BindingBag*): void {

    if (bindings) {
      // We got new bindings.
      var outgoings: BindingBag* = [];
      var inCount = 0;
      var outCount = 0;
      for (var b = 0; b < bindings.length; b++) {
        var binding = bindings[b];
        var bag = binding.bag;
        var outgoing = new BindingBag(bag);
        for (var L = 0; L < binding.entityLists.length; L++) {
          var entities = binding.entityLists[L];
          inCount++;
          var any = false;
          for (var e = 0; e < bag.entities.length; e++) {
            var entity = bag.entities[e];
            if (entities.indexOf(entity) < 0) {
              // We don't repeat bindings in SMRF.
              bind(entity);
              any = true;
            };
          };
          if (!any) {
            // Dummy entity here for when no new entities were available.
            // We send these down error branches later at split nodes.
            bind(null);
          };
        };
        outgoings.push(outgoing);
      };
      this.bindings = outgoings;
      //dump("Built " + inCount + " bindings into " + outCount);
    };

    // Continue propagation.
    this.kid.propagate(this.bindings);

    // Functions.
    function bind(entity) {
      var outEntities = entities.slice();
      outEntities.push(entity);
      outgoing.entityLists.push(outEntities);
      outCount++;
    };

  };

  function setKid(k: Number, kid: Node): void {
    if (k) throw "bad kid index " + k;
    this.kid = kid;
    initKids(this);
  };

  function setKids(kids: Node*): void {
    this.kid = kids[0];
    initKids(this);
  };

}


function emptyBindings(bags: Sample*): BindingBag* {
  var bindings: BindingBag* = [];
  for (var b = 0; b < bags.length; b++) {
    var binding = new BindingBag(bags[b]);
    // We start with one empty binding per bag.
    binding.entityLists.push([]);
    bindings.push(binding);
  };
  return bindings;
};


function initKids(parent: Node): void {
  var kids = parent.kids();
  // Set parent.
  for (var k = 0; k < kids.length; k++) {
    kids[k].parent = parent;
  };
  // Set ids if we're part of a tree already.
  var root = parent.root();
  if (root instanceof RootNode) {
    for (var k = 0; k < kids.length; k++) {
      var kid = kids[k];
      if (!kid.id) {
        kid.id = root.generateId();
        initKids(kid);
      };
    };
  };
};


function startTree(): RootNode {
  return new RootNode;
};
